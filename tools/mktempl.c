/*
 * mktempl is a program for generating 'templates' from Object Pascal
 * *.inc files. It must be used in connection with mcp.
 *
 * This program assumes that all class and iterface declarations are
 * of the form: TypeName = class/interface/record/function/procedure/array,
 * where 'class', 'interface', 'record', ... must all be in
 * lowercase. Additionally, only identifiers beginning with uppercase
 * T or I are recognized.
 * 
 * Another form of a type declaration is also recognized: [PT]TypeName =
 * ^TAnotherTypeName.
 *
 * It also processes function and procedure declarations, which do not
 * belong to any class. Declarations of the form: function/procedure
 * RoutineName produce the following output: &define RoutineName
 * &prefix&RoutineName. Declarations of this type are not recognized
 * inside classes/interfaces/records. Also, they are processed only if
 * the -r swith is present among the command line options.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LEN 256
#define MAX_FILENAME_LEN 256
#define MAX_PREFIXES 40

#define NO_TYPE_LETTER '\0'

#define TRUE 1
#define FALSE 0

/* The word most recently read */
char *word;
/* The previous word */
char *prev_word;
/* The word before the previous one. */
char *prev2_word;
/* The word before prev2_word. */
char *prev3_word;

/* String buffers. */
char buf1[MAX_WORD_LEN + 1];
char buf2[MAX_WORD_LEN + 1];
char buf3[MAX_WORD_LEN + 1];
char buf4[MAX_WORD_LEN + 1];

typedef struct{
  char *sym_prefix;
  char *mcp_prefix;
} prefix_t;

/* The table with needed prefixes.  */
prefix_t prefixes[MAX_PREFIXES];
int last_prefix = -1;

int generate_if_clauses = FALSE;
int recognize_routines = TRUE;
int global_recognize_routines = FALSE;

FILE *input;
FILE *output;

void *checked_malloc(size_t size)
{
  void *ptr = malloc(size);
  if (ptr == NULL)
    {
      perror("mktempl: Cannot allocate memory");
      abort();
    }
  return ptr;
}

void skip_whitespace()
{
  int c;

  while (isspace(c = getc(input)) && c != EOF)
    ;

  ungetc(c, input);
}

void get_word()
{
  int c, c2, i = 0;
  int alnum;
  char *temp;
  
  /* 'Rotate' the pointed buffers. */
  temp = prev3_word;
  prev3_word = prev2_word;
  prev2_word = prev_word;
  prev_word = word;
  word = temp;

  skip_whitespace();
  if ((c = getc(input)) != EOF && c != '{')
    {
      if (isalnum(c))
	alnum = TRUE;
      else
	alnum = FALSE;
      word[i++] = c;
      while ((((isalnum(c = getc(input)) || c == '_') && alnum) || 
	      (!alnum && !isspace(c) && !isalnum(c))) &&
	     c != '{' && c != EOF && i < MAX_WORD_LEN)
	{
	  if ((c2 = getc(input)) == '/' && c == '/')
	    {
	      while (getc(input) != '\n' && !feof(input))
		;
	      break;
	    }
	  else
	    ungetc(c2, input);

	  if ((c2 = getc(input)) == '*' && c == '(')
	    {
	      while ( ! ((getc(input) == '*' && getc(input) == ')') || 
			 feof(input)))
		;
	      break;
	    }
	  else
	    ungetc(c2, input);

	  word[i++] = c;
	}

      if (i >= MAX_WORD_LEN)
	{
	  fprintf(stderr, "Word too long.\n");
	  abort();
	}
      word[i] = '\0';

    } /* end c != EOF */

  if (c == '{')
    {
      while (getc(input) != '}' && !feof(input))
	;
    }
  else
    ungetc(c, input);
}

/* Pass NO_TYPE_LETTER as type_letter to suppress prepending the type
   letter.  */
void write_define(const char *stem, char type_letter)
{
  int i = -1;
  while (++i <= last_prefix)
    {
      if (generate_if_clauses)
	fprintf(output, "&ifdef %s\n", prefixes[i].mcp_prefix);
      if (type_letter != NO_TYPE_LETTER)
	{
	  fprintf(output, "&define %c%s%s %c&%s&%s\n", type_letter, 
		  prefixes[i].sym_prefix, stem, type_letter, 
		  prefixes[i].mcp_prefix, stem);
	}
      else
	{
	  fprintf(output, "&define %s%s &%s&%s\n", prefixes[i].sym_prefix, 
		  stem, prefixes[i].mcp_prefix, stem);
	}
      if (generate_if_clauses)
	fprintf(output, "&endif\n");
    }
}

void process_stream()
{
  char stem[MAX_WORD_LEN];

  /* Initialize buffers */
  buf1[0] = '\0';
  buf2[0] = '\0';
  buf3[0] = '\0';
  buf4[0] = '\0';
  word = buf1;
  prev_word = buf2;
  prev2_word = buf3;
  prev3_word = buf4;

  if (output != stdout)
    {
      fprintf(output, " &# This file was automatically generated by the mktempl program.\n &# Do not edit.\n");
    }

  while (!feof(input))
    {
      get_word();
      if (strcmp(prev_word, "=") == 0 &&
	  (prev2_word[0] == 'T' || prev2_word[0] == 'I') && 
	  (strcmp(word, "class") == 0 || strcmp(word, "interface") == 0 || 
	   strcmp(word, "record") == 0 || strcmp(word, "function") == 0 ||
	   strcmp(word, "procedure") == 0 || strcmp(word, "packed") == 0 ||
	   strcmp(word, "array") == 0))
	{
	  strcpy(stem, prev2_word + 1);
	  write_define(stem, prev2_word[0]);
	  recognize_routines = FALSE;
	}
      else if (strcmp(prev2_word, "=") == 0 && strcmp(prev_word, "^") == 0 &&
	       word[0] == 'T' && (prev3_word[0] == 'P' || prev3_word[0] == 'T'))
	{
	  strcpy(stem, prev3_word + 1);
	  write_define(stem, prev3_word[0]);
	}
      else if (global_recognize_routines && recognize_routines &&
	       (strcmp(prev2_word, "function") == 0 ||
		strcmp(prev2_word, "procedure") == 0) &&
	       strcmp(word, ".") != 0 && isalpha(prev_word[0]))
	{
	  write_define(prev_word, NO_TYPE_LETTER);
	}
      else if (strcmp(word, "end") == 0)
	{
	  recognize_routines = TRUE;
	}
    }

  /* Close file descriptors. */
  if (input != stdin)
    fclose(input);
  if (output != stdout)
    fclose(output);
}

int main(int argc, char **argv)
{
  int i, j, len;
  char outname[MAX_FILENAME_LEN + 1];
  char *str;
  
  /* Read options */
  i = 1;
  while (i < argc && argv[i][0] == '-')
    {
      if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0)
	{
	  fprintf(stderr, "Usage: mktempl [input_files]\n");
	  fprintf(stderr, "If no input files are provided then reads stdin.\n");
	  fprintf(stderr, "The extension of output files is .mcp. It is exchanged for\n");
	  fprintf(stderr, ".i if the input file name has this extension or otherwise\n");
	  fprintf(stderr, "appended to the name of the input file.\n");
	  fprintf(stderr, "If reads from stdin then writes to stdout.\n");
	  fprintf(stderr, "\n");
	  fprintf(stderr, "Options:\n");
	  fprintf(stderr, "-p [SYM_PREF:]MCP_PREF\n\tDefines a new mcp prefix MCP_PREF.\n");
	  fprintf(stderr, "\tThis is the name of a mcp define that should be\n");
	  fprintf(stderr, "\twritten on the right side of the generated\n");
	  fprintf(stderr, "\t&define clause. SYM_PREF is the prefix prepended\n");
	  fprintf(stderr, "\tto the generated define name (left side). There\n");
	  fprintf(stderr, "\tmay be up to 40 prefixes defined. SYM_PREF may be\n");
	  fprintf(stderr, "\tomitted together with ':'.\n");
	  fprintf(stderr, "-f\tEncloses all generated defines in an\n");
	  fprintf(stderr, "\t&ifdef <your_mcp_prefix> ... &endif clause.\n");
	  fprintf(stderr, "-r\tProduces output for routine declarations.\n");
	  fprintf(stderr, "\n");
	  return 0;
	}
      else if (strcmp(argv[i], "--version") == 0)
	{
	  fprintf(stderr, "mktempl 1.0\n");
	  fprintf(stderr, "This program is public domain.\n");
	  return 0;
	}
      else if (strcmp(argv[i], "-f") == 0)
	{
	  generate_if_clauses = TRUE;
	}
      else if (strcmp(argv[i], "-p") == 0)
	{ /* Prefix definition. */
	  if (last_prefix + 1 >= MAX_PREFIXES)
	    {
	      fprintf(stderr, "Too many prefixes defined.\n");
	      abort();
	    }
	  ++last_prefix;
	  ++i;
	  if (i >= argc)
	    {
	      fprintf(stderr, "Expected a prefix definition.\n");
	      abort();
	    }
	  len = strlen(argv[i]);
	  prefixes[last_prefix].sym_prefix = checked_malloc(len + 1);
	  prefixes[last_prefix].mcp_prefix = checked_malloc(len + 1);

	  for (j = 0; argv[i][j] != ':' && argv[i][j] != '\0'; ++j)
	    {
	      prefixes[last_prefix].sym_prefix[j] = argv[i][j];
	    }
	  prefixes[last_prefix].sym_prefix[j] = '\0';
	  if (argv[i][j] == ':')
	    {
	      ++j;
	      str = prefixes[last_prefix].mcp_prefix;
	      while (argv[i][j] != 0)
		*(str++) = argv[i][j++];
	      *str = argv[i][j]; /* i.e. '\0' */
	    }
	  else
	    {
	      /* no sym_prefix - should be empty - only mcp_prefix;
		 exchange, then */
	      str = prefixes[last_prefix].mcp_prefix;
	      prefixes[last_prefix].mcp_prefix = prefixes[last_prefix].sym_prefix;
	      prefixes[last_prefix].sym_prefix = str;
	      /* make sym_prefix empty */
	      *str = '\0';
	    }
	}
      else if (strcmp(argv[i], "-r") == 0)
	{
	  global_recognize_routines = TRUE;
	}
      else if (strcmp(argv[i], "-") == 0)
	{
	  break;
	}
      else if (strcmp(argv[i], "--") == 0)
	{
	  ++i;
	  break;
	}
      else
	{
	  fprintf(stderr, "Usage: mktempl [input_files]\n");
	  fprintf(stderr, "Type mktempl --help to get more info.\n");
	  return 0;
	}
      ++i;
    }

  /* No prefixes defined? */
  if (last_prefix == -1)
    { /* Use the defaults. */
      last_prefix = 0;
      prefixes[0].sym_prefix = checked_malloc(1);
      prefixes[0].mcp_prefix = checked_malloc(7);
      prefixes[0].sym_prefix[0] = '\0';
      strcpy(prefixes[0].mcp_prefix, "prefix");
    }

  /* process files */
  if (i < argc)
    {
      for (; i < argc; ++i)
	{
	  if (strcmp(argv[i], "-") == 0)
	    {
	      input = stdin;
	      output = stdout;
	    }
	  else 
	    {
	      len = strlen(argv[i]);
	      if (len + 5 > MAX_FILENAME_LEN)
		{
		  fprintf(stderr, "Argument %s too long.\n", argv[i]);
		  abort();
		}

	      if (len > 2 && strcmp(argv[i] + len - 2, ".i") == 0)
		{
		  strncpy(outname, argv[i], len - 1);
		  outname[len - 1] = 'm';
		  outname[len] = 'c';
		  outname[len + 1] = 'p';
		  outname[len + 2] = '\0';
		}
	      else
		{
		  strcpy(outname, argv[i]);
		  strcat(outname, ".mcp");
		}
	      
	      if ((input = fopen(argv[i], "r")) == NULL)
		{
		  fprintf(stderr, "Cannot open file %s\n", argv[i]);
		  abort();
		}
	      if ((output = fopen(outname, "w")) == NULL)
		{
		  fprintf(stderr, "Cannot open file %s\n", outname);
		  abort();
		}
	    }
	  process_stream();
	} /* end for */
    }
  else
    {
      input = stdin;
      output = stdout;
      process_stream();
    }

  /* clean up */
  for (i = 0; i <= last_prefix; ++i)
    {
      free(prefixes[i].sym_prefix);
      free(prefixes[i].mcp_prefix);
    }

  return 0;
}
